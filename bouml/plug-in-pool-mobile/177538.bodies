class MessageQueue
!!!1245954.java!!!	MessageQueue(inout quitAllowed : boolean)
        initIsProcessAllowedToUseConcurrent();
        mUseConcurrent = sIsProcessAllowedToUseConcurrent && !isInstrumenting();
        mQuitAllowed = quitAllowed;
        mPtr = nativeInit();
        mThread = Thread.currentThread();
        mTid = Process.myTid();
!!!1246082.java!!!	initIsProcessAllowedToUseConcurrent() : void
        if (sIsProcessAllowedToUseConcurrent != null) {
            return;
        }

        if (RavenwoodEnvironment.getInstance().isRunningOnRavenwood()) {
            sIsProcessAllowedToUseConcurrent = false;
            return;
        }

        final String processName = Process.myProcessName();
        if (processName == null) {
            // Assume that this is a host-side test and avoid concurrent mode for now.
            sIsProcessAllowedToUseConcurrent = false;
            return;
        }

        // Concurrent mode modifies behavior that is observable via reflection and is commonly
        // used by tests.
        // For now, we limit it to system processes to avoid breaking apps and their tests.
        sIsProcessAllowedToUseConcurrent = UserHandle.isCore(Process.myUid());

        if (sIsProcessAllowedToUseConcurrent) {
            // Some platform tests run in core UIDs.
            // Use this awful heuristic to detect them.
            if (processName.contains("test") || processName.contains("Test")) {
                sIsProcessAllowedToUseConcurrent = false;
            }
        } else {
            // Also explicitly allow SystemUI processes.
            // SystemUI doesn't run in a core UID, but we want to give it the performance boost,
            // and we know that it's safe to use the concurrent implementation in SystemUI.
            sIsProcessAllowedToUseConcurrent =
                    processName.equals("com.android.systemui")
                            || processName.startsWith("com.android.systemui:");
            // On Android distributions where SystemUI has a different process name,
            // the above condition may need to be adjusted accordingly.
        }

        // We can lift these restrictions in the future after we've made it possible for test
        // authors to test Looper and MessageQueue without resorting to reflection.
!!!1246210.java!!!	throwIfNotTest() : void
        final ActivityThread activityThread = ActivityThread.currentActivityThread();
        if (activityThread == null) {
            // Only tests can reach here.
            return;
        }
        final Instrumentation instrumentation = activityThread.getInstrumentation();
        if (instrumentation == null) {
            // Only tests can reach here.
            return;
        }
        if (instrumentation.isInstrumenting()) {
            return;
        }
        throw new IllegalStateException("Test-only API called not from a test!");
!!!1246338.java!!!	throwIfNotTest$ravenwood() : void
        return;
!!!1246466.java!!!	isInstrumenting() : boolean
        final ActivityThread activityThread = ActivityThread.currentActivityThread();
        if (activityThread == null) {
            return false;
        }
        final Instrumentation instrumentation = activityThread.getInstrumentation();
        return instrumentation != null && instrumentation.isInstrumenting();
!!!1246594.java!!!	finalize() : void
        try {
            dispose();
        } finally {
            super.finalize();
        }
!!!1246722.java!!!	decAndTraceMessageCount() : void
        mMessageCount.decrementAndGet();
        traceMessageCount();
!!!1246850.java!!!	incAndTraceMessageCount(inout msg : Message, in when : long) : void
        mMessageCount.incrementAndGet();
        msg.mSendingThreadName = Thread.currentThread().getName();
        msg.mEventId.set(PerfettoTrace.getFlowId());

        traceMessageCount();
        PerfettoTrace.instant(PerfettoTrace.MQ_CATEGORY, "message_queue_send")
                .addFlow(msg.mEventId.get())
                .beginProto()
                .beginNested(2004 /* message_queue */)
                .addField(2 /* receiving_thread_name */, mThread.getName())
                .addField(3 /* message_code */, msg.what)
                .addField(4 /* message_delay_ms */, when - SystemClock.uptimeMillis())
                .endNested()
                .endProto()
                .emit();
!!!1246978.java!!!	traceMessageCount() : void
        PerfettoTrace.counter(PerfettoTrace.MQ_CATEGORY, mMessageCount.get())
                .usingThreadCounterTrack(mTid, mThread.getName())
                .emit();
!!!1247106.java!!!	dispose() : void
        if (mPtr != 0) {
            nativeDestroy(mPtr);
            mPtr = 0;
        }
!!!1247362.java!!!	isIdleConcurrent() : boolean
        final long now = SystemClock.uptimeMillis();

        if (stackHasMessages(null, 0, null, null, now, mMatchDeliverableMessages, false)) {
            return false;
        }

        MessageNode msgNode = null;
        MessageNode asyncMsgNode = null;

        if (!mPriorityQueue.isEmpty()) {
            try {
                msgNode = mPriorityQueue.first();
            } catch (NoSuchElementException e) { }
        }

        if (!mAsyncPriorityQueue.isEmpty()) {
            try {
                asyncMsgNode = mAsyncPriorityQueue.first();
            } catch (NoSuchElementException e) { }
        }

        if ((msgNode != null && msgNode.getWhen() <= now)
                || (asyncMsgNode != null && asyncMsgNode.getWhen() <= now)) {
            return false;
        }

        return true;
!!!1247490.java!!!	isIdleLegacy() : boolean
        synchronized (this) {
            final long now = SystemClock.uptimeMillis();
            return mMessages == null || now < mMessages.when;
        }
!!!1247618.java!!!	isIdle() : boolean
        if (mUseConcurrent) {
            return isIdleConcurrent();
        } else {
            return isIdleLegacy();
        }
!!!1247746.java!!!	addIdleHandlerConcurrent(inout handler : MessageQueue::IdleHandler) : void
        synchronized (mIdleHandlersLock) {
            mIdleHandlers.add(handler);
        }
!!!1247874.java!!!	addIdleHandlerLegacy(inout handler : MessageQueue::IdleHandler) : void
        synchronized (this) {
            mIdleHandlers.add(handler);
        }
!!!1248002.java!!!	addIdleHandler(inout handler : MessageQueue::IdleHandler) : void
        if (handler == null) {
            throw new NullPointerException("Can't add a null IdleHandler");
        }
        if (mUseConcurrent) {
            addIdleHandlerConcurrent(handler);
        } else {
            addIdleHandlerLegacy(handler);
        }
!!!1248130.java!!!	removeIdleHandlerConcurrent(inout handler : MessageQueue::IdleHandler) : void
        synchronized (mIdleHandlersLock) {
            mIdleHandlers.remove(handler);
        }
!!!1248258.java!!!	removeIdleHandlerLegacy(inout handler : MessageQueue::IdleHandler) : void
        synchronized (this) {
            mIdleHandlers.remove(handler);
        }
!!!1248386.java!!!	removeIdleHandler(inout handler : MessageQueue::IdleHandler) : void
        if (mUseConcurrent) {
            removeIdleHandlerConcurrent(handler);
        } else {
            removeIdleHandlerLegacy(handler);
        }
!!!1248514.java!!!	isPollingConcurrent() : boolean
        // If the loop is quitting then it must not be idling.
        // We can assume mPtr != 0 when sQuitting is false.
        return !((boolean) sQuitting.getVolatile(this)) && nativeIsPolling(mPtr);
!!!1248642.java!!!	isPollingLegacy() : boolean
        synchronized (this) {
            return isPollingLocked();
        }
!!!1248770.java!!!	isPolling() : boolean
        if (mUseConcurrent) {
            return isPollingConcurrent();
        } else {
            return isPollingLegacy();
        }
!!!1248898.java!!!	isPollingLocked() : boolean
        // If the loop is quitting then it must not be idling.
        // We can assume mPtr != 0 when mQuitting is false.
        return !mQuitting && nativeIsPolling(mPtr);
!!!1249026.java!!!	addOnFileDescriptorEventListenerConcurrent(inout fd : FileDescriptor, in events : int, inout listener : MessageQueue::OnFileDescriptorEventListener) : void
        synchronized (mFileDescriptorRecordsLock) {
            updateOnFileDescriptorEventListenerLocked(fd, events, listener);
        }
!!!1249154.java!!!	addOnFileDescriptorEventListenerLegacy(inout fd : FileDescriptor, in events : int, inout listener : MessageQueue::OnFileDescriptorEventListener) : void
        synchronized (this) {
            updateOnFileDescriptorEventListenerLocked(fd, events, listener);
        }
!!!1249282.java!!!	addOnFileDescriptorEventListener(inout fd : FileDescriptor, in events : int, inout listener : MessageQueue::OnFileDescriptorEventListener) : void
        if (fd == null) {
            throw new IllegalArgumentException("fd must not be null");
        }
        if (listener == null) {
            throw new IllegalArgumentException("listener must not be null");
        }

        if (mUseConcurrent) {
            addOnFileDescriptorEventListenerConcurrent(fd, events, listener);
        } else {
            addOnFileDescriptorEventListenerLegacy(fd, events, listener);
        }
!!!1249410.java!!!	removeOnFileDescriptorEventListenerConcurrent(inout fd : FileDescriptor) : void
        synchronized (mFileDescriptorRecordsLock) {
            updateOnFileDescriptorEventListenerLocked(fd, 0, null);
        }
!!!1249538.java!!!	removeOnFileDescriptorEventListenerLegacy(inout fd : FileDescriptor) : void
        synchronized (this) {
            updateOnFileDescriptorEventListenerLocked(fd, 0, null);
        }
!!!1249666.java!!!	removeOnFileDescriptorEventListener(inout fd : FileDescriptor) : void
        if (fd == null) {
            throw new IllegalArgumentException("fd must not be null");
        }
        if (mUseConcurrent) {
            removeOnFileDescriptorEventListenerConcurrent(fd);
        } else {
            removeOnFileDescriptorEventListenerLegacy(fd);
        }
!!!1249794.java!!!	updateOnFileDescriptorEventListenerLocked(inout fd : FileDescriptor, in events : int, inout listener : MessageQueue::OnFileDescriptorEventListener) : void
        final int fdNum = fd.getInt$();

        int index = -1;
        FileDescriptorRecord record = null;
        if (mFileDescriptorRecords != null) {
            index = mFileDescriptorRecords.indexOfKey(fdNum);
            if (index >= 0) {
                record = mFileDescriptorRecords.valueAt(index);
                if (record != null && record.mEvents == events) {
                    return;
                }
            }
        }

        if (events != 0) {
            events |= OnFileDescriptorEventListener.EVENT_ERROR;
            if (record == null) {
                if (mFileDescriptorRecords == null) {
                    mFileDescriptorRecords = new SparseArray<FileDescriptorRecord>();
                }
                record = new FileDescriptorRecord(fd, events, listener);
                mFileDescriptorRecords.put(fdNum, record);
            } else {
                record.mListener = listener;
                record.mEvents = events;
                record.mSeq += 1;
            }
            nativeSetFileDescriptorEvents(mPtr, fdNum, events);
        } else if (record != null) {
            record.mEvents = 0;
            mFileDescriptorRecords.removeAt(index);
            nativeSetFileDescriptorEvents(mPtr, fdNum, 0);
        }
!!!1249922.java!!!	dispatchEvents(in fd : int, in events : int) : int
        // Get the file descriptor record and any state that might change.
        final FileDescriptorRecord record;
        final int oldWatchedEvents;
        final OnFileDescriptorEventListener listener;
        final int seq;
        if (mUseConcurrent) {
            synchronized (mFileDescriptorRecordsLock) {
                record = mFileDescriptorRecords.get(fd);
                if (record == null) {
                    return 0; // spurious, no listener registered
                }

                oldWatchedEvents = record.mEvents;
                events &= oldWatchedEvents; // filter events based on current watched set
                if (events == 0) {
                    return oldWatchedEvents; // spurious, watched events changed
                }

                listener = record.mListener;
                seq = record.mSeq;
            }
        } else {
            synchronized (this) {
                record = mFileDescriptorRecords.get(fd);
                if (record == null) {
                    return 0; // spurious, no listener registered
                }

                oldWatchedEvents = record.mEvents;
                events &= oldWatchedEvents; // filter events based on current watched set
                if (events == 0) {
                    return oldWatchedEvents; // spurious, watched events changed
                }

                listener = record.mListener;
                seq = record.mSeq;
            }
        }
        // Invoke the listener outside of the lock.
        int newWatchedEvents = listener.onFileDescriptorEvents(
                record.mDescriptor, events);
        if (newWatchedEvents != 0) {
            newWatchedEvents |= OnFileDescriptorEventListener.EVENT_ERROR;
        }

        // Update the file descriptor record if the listener changed the set of
        // events to watch and the listener itself hasn't been updated since.
        if (newWatchedEvents != oldWatchedEvents) {
            if (mUseConcurrent) {
                synchronized (mFileDescriptorRecordsLock) {
                    int index = mFileDescriptorRecords.indexOfKey(fd);
                    if (index >= 0 && mFileDescriptorRecords.valueAt(index) == record
                            && record.mSeq == seq) {
                        record.mEvents = newWatchedEvents;
                        if (newWatchedEvents == 0) {
                            mFileDescriptorRecords.removeAt(index);
                        }
                    }
                }
            } else {
                synchronized (this) {
                    int index = mFileDescriptorRecords.indexOfKey(fd);
                    if (index >= 0 && mFileDescriptorRecords.valueAt(index) == record
                            && record.mSeq == seq) {
                        record.mEvents = newWatchedEvents;
                        if (newWatchedEvents == 0) {
                            mFileDescriptorRecords.removeAt(index);
                        }
                    }
                }
            }
        }

        // Return the new set of events to watch for native code to take care of.
        return newWatchedEvents;
!!!1250050.java!!!	nextMessage(inout peek : boolean, inout returnEarliest : boolean) : Message
        int i = 0;

        while (true) {
            if (DEBUG) {
                Log.d(TAG_C, "nextMessage loop #" + i);
                i++;
            }

            mDrainingLock.lock();
            mNextIsDrainingStack = true;
            mDrainingLock.unlock();

            /*
             * Set our state to active, drain any items from the stack into our priority queues
             */
            StackNode oldTop;
            oldTop = swapAndSetStackStateActive();
            drainStack(oldTop);

            mDrainingLock.lock();
            mNextIsDrainingStack = false;
            mDrainCompleted.signalAll();
            mDrainingLock.unlock();

            /*
             * The objective of this next block of code is to:
             *  - find a message to return (if any is ready)
             *  - find a next message we would like to return, after scheduling.
             *     - we make our scheduling decision based on this next message (if it exists).
             *
             * We have two queues to juggle and the presence of barriers throws an additional
             * wrench into our plans.
             *
             * The last wrinkle is that remove() may delete items from underneath us. If we hit
             * that case, we simply restart the loop.
             */

            /* Get the first node from each queue */
            Iterator<MessageNode> queueIter = mPriorityQueue.iterator();
            MessageNode msgNode = iterateNext(queueIter);
            Iterator<MessageNode> asyncQueueIter = mAsyncPriorityQueue.iterator();
            MessageNode asyncMsgNode = iterateNext(asyncQueueIter);

            if (DEBUG) {
                if (msgNode != null) {
                    Message msg = msgNode.mMessage;
                    Log.d(TAG_C, "Next found node what: " + msg.what + " when: " + msg.when
                            + " seq: " + msgNode.mInsertSeq + "barrier: "
                            + msgNode.isBarrier() + " now: " + SystemClock.uptimeMillis());
                }
                if (asyncMsgNode != null) {
                    Message msg = asyncMsgNode.mMessage;
                    Log.d(TAG_C, "Next found async node what: " + msg.what + " when: " + msg.when
                            + " seq: " + asyncMsgNode.mInsertSeq + "barrier: "
                            + asyncMsgNode.isBarrier() + " now: "
                            + SystemClock.uptimeMillis());
                }
            }

            /*
             * the node which we will return, null if none are ready
             */
            MessageNode found = null;
            /*
             * The node from which we will determine our next wakeup time.
             * Null indicates there is no next message ready. If we found a node,
             * we can leave this null as Looper will call us again after delivering
             * the message.
             */
            MessageNode next = null;

            long now = SystemClock.uptimeMillis();
            /*
             * If we have a barrier we should return the async node (if it exists and is ready)
             */
            if (msgNode != null && msgNode.isBarrier()) {
                if (asyncMsgNode != null && (returnEarliest || now >= asyncMsgNode.getWhen())) {
                    found = asyncMsgNode;
                } else {
                    next = asyncMsgNode;
                }
            } else { /* No barrier. */
                MessageNode earliest;
                /*
                 * If we have two messages, pick the earliest option from either queue.
                 * Otherwise grab whichever node is non-null. If both are null we'll fall through.
                 */
                earliest = pickEarliestNode(msgNode, asyncMsgNode);

                if (earliest != null) {
                    if (returnEarliest || now >= earliest.getWhen()) {
                        found = earliest;
                    } else {
                        next = earliest;
                    }
                }
            }

            if (DEBUG) {
                if (found != null) {
                    Message msg = found.mMessage;
                    Log.d(TAG_C, " Will deliver node what: " + msg.what + " when: " + msg.when
                            + " seq: " + found.mInsertSeq + " barrier: " + found.isBarrier()
                            + " async: " + found.isAsync() + " now: "
                            + SystemClock.uptimeMillis());
                } else {
                    Log.d(TAG_C, "No node to deliver");
                }
                if (next != null) {
                    Message msg = next.mMessage;
                    Log.d(TAG_C, "Next node what: " + msg.what + " when: " + msg.when + " seq: "
                            + next.mInsertSeq + " barrier: " + next.isBarrier() + " async: "
                            + next.isAsync()
                            + " now: " + SystemClock.uptimeMillis());
                } else {
                    Log.d(TAG_C, "No next node");
                }
            }

            /*
             * If we have a found message, we will get called again so there's no need to set state.
             * In that case we can leave our state as ACTIVE.
             *
             * Otherwise we should determine how to park the thread.
             */
            StateNode nextOp = sStackStateActive;
            if (found == null) {
                if (next == null) {
                    /* No message to deliver, sleep indefinitely */
                    mNextPollTimeoutMillis = -1;
                    nextOp = sStackStateParked;
                    if (DEBUG) {
                        Log.d(TAG_C, "nextMessage next state is StackStateParked");
                    }
                } else {
                    /* Message not ready, or we found one to deliver already, set a timeout */
                    long nextMessageWhen = next.getWhen();
                    if (nextMessageWhen > now) {
                        mNextPollTimeoutMillis = (int) Math.min(nextMessageWhen - now,
                                Integer.MAX_VALUE);
                    } else {
                        mNextPollTimeoutMillis = 0;
                    }

                    mStackStateTimedPark.mWhenToWake = now + mNextPollTimeoutMillis;
                    nextOp = mStackStateTimedPark;
                    if (DEBUG) {
                        Log.d(TAG_C, "nextMessage next state is StackStateTimedParked timeout ms "
                                + mNextPollTimeoutMillis + " mWhenToWake: "
                                + mStackStateTimedPark.mWhenToWake + " now " + now);
                    }
                }
            }

            /*
             * Try to swap our state from Active back to Park or TimedPark. If we raced with
             * enqueue, loop back around to pick up any new items.
             */
            if (sState.compareAndSet(this, sStackStateActive, nextOp)) {
                mMessageCounts.clearCounts();
                if (found != null) {
                    if (!peek && !removeFromPriorityQueue(found)) {
                        /*
                         * RemoveMessages() might be able to pull messages out from under us
                         * However we can detect that here and just loop around if it happens.
                         */
                        continue;
                    }

                    if (TRACE) {
                        Trace.setCounter("MQ.Delivered", mMessagesDelivered.incrementAndGet());
                    }
                    return found.mMessage;
                }
                return null;
            }
        }
!!!1250178.java!!!	nextConcurrent() : Message
        final long ptr = mPtr;
        if (ptr == 0) {
            return null;
        }

        mNextPollTimeoutMillis = 0;
        int pendingIdleHandlerCount = -1; // -1 only during first iteration
        while (true) {
            if (mNextPollTimeoutMillis != 0) {
                Binder.flushPendingCommands();
            }

            mMessageDirectlyQueued = false;
            nativePollOnce(ptr, mNextPollTimeoutMillis);

            Message msg = nextMessage(false, false);
            if (msg != null) {
                msg.markInUse();
                decAndTraceMessageCount();
                return msg;
            }

            if ((boolean) sQuitting.getVolatile(this)) {
                return null;
            }

            synchronized (mIdleHandlersLock) {
                // If first time idle, then get the number of idlers to run.
                // Idle handles only run if the queue is empty or if the first message
                // in the queue (possibly a barrier) is due to be handled in the future.
                if (pendingIdleHandlerCount < 0
                        && isIdle()) {
                    pendingIdleHandlerCount = mIdleHandlers.size();
                }
                if (pendingIdleHandlerCount <= 0) {
                    // No idle handlers to run.  Loop and wait some more.
                    continue;
                }

                if (mPendingIdleHandlers == null) {
                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
                }
                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
            }

            // Run the idle handlers.
            // We only ever reach this code block during the first iteration.
            for (int i = 0; i < pendingIdleHandlerCount; i++) {
                final IdleHandler idler = mPendingIdleHandlers[i];
                mPendingIdleHandlers[i] = null; // release the reference to the handler

                boolean keep = false;
                try {
                    keep = idler.queueIdle();
                } catch (Throwable t) {
                    Log.wtf(TAG_C, "IdleHandler threw exception", t);
                }

                if (!keep) {
                    synchronized (mIdleHandlersLock) {
                        mIdleHandlers.remove(idler);
                    }
                }
            }

            // Reset the idle handler count to 0 so we do not run them again.
            pendingIdleHandlerCount = 0;

            // While calling an idle handler, a new message could have been delivered
            // so go back and look again for a pending message without waiting.
            mNextPollTimeoutMillis = 0;
        }
!!!1250306.java!!!	nextLegacy() : Message
        // Return here if the message loop has already quit and been disposed.
        // This can happen if the application tries to restart a looper after quit
        // which is not supported.
        final long ptr = mPtr;
        if (ptr == 0) {
            return null;
        }

        int pendingIdleHandlerCount = -1; // -1 only during first iteration
        int nextPollTimeoutMillis = 0;
        for (;;) {
            if (nextPollTimeoutMillis != 0) {
                Binder.flushPendingCommands();
            }

            nativePollOnce(ptr, nextPollTimeoutMillis);

            synchronized (this) {
                // Try to retrieve the next message.  Return if found.
                final long now = SystemClock.uptimeMillis();
                Message prevMsg = null;
                Message msg = mMessages;
                if (msg != null && msg.target == null) {
                    // Stalled by a barrier.  Find the next asynchronous message in the queue.
                    do {
                        prevMsg = msg;
                        msg = msg.next;
                    } while (msg != null && !msg.isAsynchronous());
                }
                if (msg != null) {
                    if (now < msg.when) {
                        // Next message is not ready.  Set a timeout to wake up when it is ready.
                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                    } else {
                        // Got a message.
                        mBlocked = false;
                        if (prevMsg != null) {
                            prevMsg.next = msg.next;
                            if (prevMsg.next == null) {
                                mLast = prevMsg;
                            }
                        } else {
                            mMessages = msg.next;
                            if (msg.next == null) {
                                mLast = null;
                            }
                        }
                        msg.next = null;
                        if (DEBUG) Log.v(TAG_L, "Returning message: " + msg);
                        msg.markInUse();
                        if (msg.isAsynchronous()) {
                            mAsyncMessageCount--;
                        }
                        decAndTraceMessageCount();
                        if (TRACE) {
                            Trace.setCounter("MQ.Delivered", mMessagesDelivered.incrementAndGet());
                        }
                        return msg;
                    }
                } else {
                    // No more messages.
                    nextPollTimeoutMillis = -1;
                }

                // Process the quit message now that all pending messages have been handled.
                if (mQuitting) {
                    dispose();
                    return null;
                }

                // If first time idle, then get the number of idlers to run.
                // Idle handles only run if the queue is empty or if the first message
                // in the queue (possibly a barrier) is due to be handled in the future.
                if (pendingIdleHandlerCount < 0
                        && (mMessages == null || now < mMessages.when)) {
                    pendingIdleHandlerCount = mIdleHandlers.size();
                }
                if (pendingIdleHandlerCount <= 0) {
                    // No idle handlers to run.  Loop and wait some more.
                    mBlocked = true;
                    continue;
                }

                if (mPendingIdleHandlers == null) {
                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
                }
                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
            }

            // Run the idle handlers.
            // We only ever reach this code block during the first iteration.
            for (int i = 0; i < pendingIdleHandlerCount; i++) {
                final IdleHandler idler = mPendingIdleHandlers[i];
                mPendingIdleHandlers[i] = null; // release the reference to the handler

                boolean keep = false;
                try {
                    keep = idler.queueIdle();
                } catch (Throwable t) {
                    Log.wtf(TAG_L, "IdleHandler threw exception", t);
                }

                if (!keep) {
                    synchronized (this) {
                        mIdleHandlers.remove(idler);
                    }
                }
            }

            // Reset the idle handler count to 0 so we do not run them again.
            pendingIdleHandlerCount = 0;

            // While calling an idle handler, a new message could have been delivered
            // so go back and look again for a pending message without waiting.
            nextPollTimeoutMillis = 0;
        }
!!!1250434.java!!!	next() : Message
        if (mUseConcurrent) {
            return nextConcurrent();
        } else {
            return nextLegacy();
        }
!!!1250562.java!!!	quit(inout safe : boolean) : void
        if (!mQuitAllowed) {
            throw new IllegalStateException("Main thread not allowed to quit.");
        }

        if (mUseConcurrent) {
            synchronized (mIdleHandlersLock) {
                if (sQuitting.compareAndSet(this, false, true)) {
                    if (safe) {
                        removeAllFutureMessages();
                    } else {
                        removeAllMessages();
                    }

                    // We can assume mPtr != 0 because sQuitting was previously false.
                    nativeWake(mPtr);
                }
            }
        } else {
            synchronized (this) {
                if (mQuitting) {
                    return;
                }
                mQuitting = true;

                if (safe) {
                    removeAllFutureMessagesLocked();
                } else {
                    removeAllMessagesLocked();
                }

                // We can assume mPtr != 0 because mQuitting was previously false.
                nativeWake(mPtr);
            }
        }
!!!1250690.java!!!	postSyncBarrierConcurrent() : int
        return postSyncBarrier(SystemClock.uptimeMillis());

!!!1250818.java!!!	postSyncBarrierLegacy() : int
        return postSyncBarrier(SystemClock.uptimeMillis());
!!!1250946.java!!!	postSyncBarrier() : int
        if (mUseConcurrent) {
            return postSyncBarrierConcurrent();
        } else {
            return postSyncBarrierLegacy();
        }
!!!1251074.java!!!	postSyncBarrier(in when : long) : int
        // Enqueue a new sync barrier token.
        // We don't need to wake the queue because the purpose of a barrier is to stall it.
        if (mUseConcurrent) {
            final int token = mNextBarrierTokenAtomic.getAndIncrement();

            // b/376573804: apps and tests may expect to be able to use reflection
            // to read this value. Make some effort to support this legacy use case.
            mNextBarrierToken = token + 1;

            final Message msg = Message.obtain();

            msg.markInUse();
            msg.arg1 = token;
            incAndTraceMessageCount(msg, when);

            if (!enqueueMessageUnchecked(msg, when)) {
                Log.wtf(TAG_C, "Unexpected error while adding sync barrier!");
                return -1;
            }

            return token;
        }

        synchronized (this) {
            final int token = mNextBarrierToken++;
            final Message msg = Message.obtain();
            msg.markInUse();
            msg.when = when;
            msg.arg1 = token;
            incAndTraceMessageCount(msg, when);

            if (Flags.messageQueueTailTracking() && mLast != null && mLast.when <= when) {
                /* Message goes to tail of list */
                mLast.next = msg;
                mLast = msg;
                msg.next = null;
                return token;
            }

            Message prev = null;
            Message p = mMessages;
            if (when != 0) {
                while (p != null && p.when <= when) {
                    prev = p;
                    p = p.next;
                }
            }

            if (p == null) {
                /* We reached the tail of the list, or list is empty. */
                mLast = msg;
            }

            if (prev != null) { // invariant: p == prev.next
                msg.next = p;
                prev.next = msg;
            } else {
                msg.next = p;
                mMessages = msg;
            }
            return token;
        }
!!!1251458.java!!!	removeSyncBarrierConcurrent(in token : int) : void
        boolean removed;
        MessageNode first;
        final MatchBarrierToken matchBarrierToken = new MatchBarrierToken(token);

        try {
            /* Retain the first element to see if we are currently stuck on a barrier. */
            first = mPriorityQueue.first();
        } catch (NoSuchElementException e) {
            /* The queue is empty */
            first = null;
        }

        removed = findOrRemoveMessages(null, 0, null, null, 0, matchBarrierToken, true);
        if (removed && first != null) {
            Message m = first.mMessage;
            if (m.target == null && m.arg1 == token) {
                /* Wake up next() in case it was sleeping on this barrier. */
                nativeWake(mPtr);
            }
        } else if (!removed) {
            throw new IllegalStateException("The specified message queue synchronization "
                    + " barrier token has not been posted or has already been removed.");
        }
!!!1251586.java!!!	removeSyncBarrierLegacy(in token : int) : void
        synchronized (this) {
            Message prev = null;
            Message p = mMessages;
            while (p != null && (p.target != null || p.arg1 != token)) {
                prev = p;
                p = p.next;
            }
            if (p == null) {
                throw new IllegalStateException("The specified message queue synchronization "
                        + " barrier token has not been posted or has already been removed.");
            }
            final boolean needWake;
            if (prev != null) {
                prev.next = p.next;
                if (prev.next == null) {
                    mLast = prev;
                }
                needWake = false;
            } else {
                mMessages = p.next;
                if (mMessages == null) {
                    mLast = null;
                }
                needWake = mMessages == null || mMessages.target != null;
            }
            p.recycleUnchecked();
            decAndTraceMessageCount();

            // If the loop is quitting then it is already awake.
            // We can assume mPtr != 0 when mQuitting is false.
            if (needWake && !mQuitting) {
                nativeWake(mPtr);
            }
        }
!!!1251714.java!!!	removeSyncBarrier(in token : int) : void
        // Remove a sync barrier token from the queue.
        // If the queue is no longer stalled by a barrier then wake it.
        if (mUseConcurrent) {
            removeSyncBarrierConcurrent(token);
        } else {
            removeSyncBarrierLegacy(token);
        }

!!!1251842.java!!!	enqueueMessageConcurrent(inout msg : Message, in when : long) : boolean
        if (msg.isInUse()) {
            throw new IllegalStateException(msg + " This message is already in use.");
        }

        return enqueueMessageUnchecked(msg, when);
!!!1251970.java!!!	enqueueMessageLegacy(inout msg : Message, in when : long) : boolean
        synchronized (this) {
            if (msg.isInUse()) {
                throw new IllegalStateException(msg + " This message is already in use.");
            }

            if (mQuitting) {
                IllegalStateException e = new IllegalStateException(
                        msg.target + " sending message to a Handler on a dead thread");
                Log.w(TAG_L, e.getMessage(), e);
                msg.recycle();
                return false;
            }

            msg.markInUse();
            msg.when = when;
            incAndTraceMessageCount(msg, when);

            Message p = mMessages;
            boolean needWake;
            if (p == null || when == 0 || when < p.when) {
                // New head, wake up the event queue if blocked.
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
                if (p == null) {
                    mLast = mMessages;
                }
            } else {
                // Message is to be inserted at tail or middle of queue. Usually we don't have to
                // wake up the event queue unless there is a barrier at the head of the queue and
                // the message is the earliest asynchronous message in the queue.
                needWake = mBlocked && p.target == null && msg.isAsynchronous();

                // For readability, we split this portion of the function into two blocks based on
                // whether tail tracking is enabled. This has a minor implication for the case
                // where tail tracking is disabled. See the comment below.
                if (Flags.messageQueueTailTracking()) {
                    if (when >= mLast.when) {
                        needWake = needWake && mAsyncMessageCount == 0;
                        msg.next = null;
                        mLast.next = msg;
                        mLast = msg;
                    } else {
                        // Inserted within the middle of the queue.
                        Message prev;
                        for (;;) {
                            prev = p;
                            p = p.next;
                            if (p == null || when < p.when) {
                                break;
                            }
                            if (needWake && p.isAsynchronous()) {
                                needWake = false;
                            }
                        }
                        if (p == null) {
                            /* Inserting at tail of queue */
                            mLast = msg;
                        }
                        msg.next = p; // invariant: p == prev.next
                        prev.next = msg;
                    }
                } else {
                    Message prev;
                    for (;;) {
                        prev = p;
                        p = p.next;
                        if (p == null || when < p.when) {
                            break;
                        }
                        if (needWake && p.isAsynchronous()) {
                            needWake = false;
                        }
                    }
                    msg.next = p; // invariant: p == prev.next
                    prev.next = msg;

                    /*
                     * If this block is executing then we have a build without tail tracking -
                     * specifically: Flags.messageQueueTailTracking() == false. This is determined
                     * at build time so the flag won't change on us during runtime.
                     *
                     * Since we don't want to pepper the code with extra checks, we only check
                     * for tail tracking when we might use mLast. Otherwise, we continue to update
                     * mLast as the tail of the list.
                     *
                     * In this case however we are not maintaining mLast correctly. Since we never
                     * use it, this is fine. However, we run the risk of leaking a reference.
                     * So set mLast to null in this case to avoid any Message leaks. The other
                     * sites will never use the value so we are safe against null pointer derefs.
                     */
                    mLast = null;
                }
            }

            if (msg.isAsynchronous()) {
                mAsyncMessageCount++;
            }

            // We can assume mPtr != 0 because mQuitting is false.
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
!!!1252098.java!!!	enqueueMessage(inout msg : Message, in when : long) : boolean
        if (msg.target == null) {
            throw new IllegalArgumentException("Message must have a target.");
        }

        if (mUseConcurrent) {
            return enqueueMessageConcurrent(msg, when);
        } else {
            return enqueueMessageLegacy(msg, when);
        }
!!!1252226.java!!!	legacyPeekOrPoll(inout peek : boolean) : Message
        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null && msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null && !msg.isAsynchronous());
            }
            if (msg != null) {
                if (peek) {
                    return msg;
                }
                if (now >= msg.when) {
                    // Got a message.
                    mBlocked = false;
                }
                if (prevMsg != null) {
                    prevMsg.next = msg.next;
                    if (prevMsg.next == null) {
                        mLast = prevMsg;
                    }
                } else {
                    mMessages = msg.next;
                    if (msg.next == null) {
                        mLast = null;
                    }
                }
                msg.next = null;
                msg.markInUse();
                if (msg.isAsynchronous()) {
                    mAsyncMessageCount--;
                }
                decAndTraceMessageCount();
                if (TRACE) {
                    Trace.setCounter("MQ.Delivered", mMessagesDelivered.incrementAndGet());
                }
                return msg;
            }
        }
        return null;
!!!1252354.java!!!	peekWhenForTest() : Long
        throwIfNotTest();
        Message ret;
        if (mUseConcurrent) {
            ret = nextMessage(true, true);
        } else {
            ret = legacyPeekOrPoll(true);
        }
        return ret != null ? ret.when : null;
!!!1252482.java!!!	pollForTest() : Message
        throwIfNotTest();
        if (mUseConcurrent) {
            return nextMessage(false, true);
        } else {
            return legacyPeekOrPoll(false);
        }
!!!1252610.java!!!	isBlockedOnSyncBarrier() : boolean
        throwIfNotTest();
        if (mUseConcurrent) {
            // Call nextMessage to get the stack drained into our priority queues
            nextMessage(true, false);

            Iterator<MessageNode> queueIter = mPriorityQueue.iterator();
            MessageNode queueNode = iterateNext(queueIter);

            return (queueNode != null && queueNode.isBarrier());
        } else {
            Message msg = mMessages;
            return msg != null && msg.target == null;
        }
!!!1252866.java!!!	hasMessagesConcurrent(inout h : Handler, in what : int, inout object : Object) : boolean
        return findOrRemoveMessages(h, what, object, null, 0, mMatchHandlerWhatAndObject,
                false);
!!!1252994.java!!!	hasMessagesLegacy(inout h : Handler, in what : int, inout object : Object) : boolean
        synchronized (this) {
            Message p = mMessages;
            while (p != null) {
                if (p.target == h && p.what == what && (object == null || p.obj == object)) {
                    return true;
                }
                p = p.next;
            }
            return false;
        }
!!!1253122.java!!!	hasMessages(inout h : Handler, in what : int, inout object : Object) : boolean
        if (h == null) {
            return false;
        }
        if (mUseConcurrent) {
            return hasMessagesConcurrent(h, what, object);
        } else {
            return hasMessagesLegacy(h, what, object);
        }
!!!1253378.java!!!	hasEqualMessagesConcurrent(inout h : Handler, in what : int, inout object : Object) : boolean
        return findOrRemoveMessages(h, what, object, null, 0, mMatchHandlerWhatAndObjectEquals,
                false);
!!!1253506.java!!!	hasEqualMessagesLegacy(inout h : Handler, in what : int, inout object : Object) : boolean
        synchronized (this) {
            Message p = mMessages;
            while (p != null) {
                if (p.target == h && p.what == what && (object == null || object.equals(p.obj))) {
                    return true;
                }
                p = p.next;
            }
            return false;
        }
!!!1253634.java!!!	hasEqualMessages(inout h : Handler, in what : int, inout object : Object) : boolean
        if (h == null) {
            return false;
        }
        if (mUseConcurrent) {
            return hasEqualMessagesConcurrent(h, what, object);
        } else {
            return hasEqualMessagesLegacy(h, what, object);
        }
!!!1253890.java!!!	hasMessagesConcurrent(inout h : Handler, inout r : Runnable, inout object : Object) : boolean
        return findOrRemoveMessages(h, -1, object, r, 0, mMatchHandlerRunnableAndObject,
                false);
!!!1254018.java!!!	hasMessagesLegacy(inout h : Handler, inout r : Runnable, inout object : Object) : boolean
        synchronized (this) {
            Message p = mMessages;
            while (p != null) {
                if (p.target == h && p.callback == r && (object == null || p.obj == object)) {
                    return true;
                }
                p = p.next;
            }
            return false;
        }
!!!1254146.java!!!	hasMessages(inout h : Handler, inout r : Runnable, inout object : Object) : boolean
        if (h == null) {
            return false;
        }
        if (mUseConcurrent) {
            return hasMessagesConcurrent(h, r, object);
        } else {
            return hasMessagesLegacy(h, r, object);
        }
!!!1254402.java!!!	hasMessagesConcurrent(inout h : Handler) : boolean
        return findOrRemoveMessages(h, -1, null, null, 0, mMatchHandler, false);
!!!1254530.java!!!	hasMessagesLegacy(inout h : Handler) : boolean
        synchronized (this) {
            Message p = mMessages;
            while (p != null) {
                if (p.target == h) {
                    return true;
                }
                p = p.next;
            }
            return false;
        }
!!!1254658.java!!!	hasMessages(inout h : Handler) : boolean
        if (h == null) {
            return false;
        }
        if (mUseConcurrent) {
            return hasMessagesConcurrent(h);
        } else {
            return hasMessagesLegacy(h);
        }
!!!1254786.java!!!	removeMessagesConcurrent(inout h : Handler, in what : int, inout object : Object) : void
        findOrRemoveMessages(h, what, object, null, 0, mMatchHandlerWhatAndObject, true);
!!!1254914.java!!!	removeMessagesLegacy(inout h : Handler, in what : int, inout object : Object) : void
        synchronized (this) {
            Message p = mMessages;

            // Remove all messages at front.
            while (p != null && p.target == h && p.what == what
                   && (object == null || p.obj == object)) {
                Message n = p.next;
                mMessages = n;
                if (p.isAsynchronous()) {
                    mAsyncMessageCount--;
                }
                p.recycleUnchecked();
                decAndTraceMessageCount();
                p = n;
            }

            if (p == null) {
                mLast = mMessages;
            }

            // Remove all messages after front.
            while (p != null) {
                Message n = p.next;
                if (n != null) {
                    if (n.target == h && n.what == what
                            && (object == null || n.obj == object)) {
                        Message nn = n.next;
                        if (n.isAsynchronous()) {
                            mAsyncMessageCount--;
                        }
                        n.recycleUnchecked();
                        decAndTraceMessageCount();
                        p.next = nn;
                        if (p.next == null) {
                            mLast = p;
                        }
                        continue;
                    }
                }
                p = n;
            }
        }
!!!1255042.java!!!	removeMessages(inout h : Handler, in what : int, inout object : Object) : void
        if (h == null) {
            return;
        }
        if (mUseConcurrent) {
            removeMessagesConcurrent(h, what, object);
        } else {
            removeMessagesLegacy(h, what, object);
        }
!!!1255170.java!!!	removeEqualMessagesConcurrent(inout h : Handler, in what : int, inout object : Object) : void
            findOrRemoveMessages(h, what, object, null, 0, mMatchHandlerWhatAndObjectEquals, true);
